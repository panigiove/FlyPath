use wg_2024::packet::{NackType, Packet};

fn old_packet_handler(&mut self, mut packet: Packet) {
    // read Drone Protocol for the precise description of steps

    match &packet.pack_type {
        PacketType::FloodRequest(req) => {
            let mut floodrequest = req.clone();
            if !self.precFloodId.contains_key(&floodrequest.flood_id) {
                let mut no_neightbours = true;
                self.precFloodId
                    .insert(floodrequest.flood_id, floodrequest.flood_id);
                floodrequest.path_trace.push((self.id, NodeType::Drone));
                let new_floodrequest = self.floodrequest_creator(&packet, floodrequest.clone());
                for (i, j) in &self.packet_send {
                    if *i != floodrequest.path_trace[floodrequest.path_trace.len() - 2].0 {
                        self.packet_sender(new_floodrequest.clone());
                        self.controller_sender(DroneEvent::PacketSent(
                            new_floodrequest.clone(),
                        ));
                        no_neightbours = false;
                    }
                }
                if !no_neightbours {
                    let floodresponse = self.floodresponse_creator(&packet, &floodrequest);
                    self.packet_sender(floodresponse);
                }
            } else {
                floodrequest.path_trace.push((self.id, NodeType::Drone));
                let floodresponse = self.floodresponse_creator(&packet, &floodrequest);
                self.packet_sender(floodresponse);
            }
        }
        _ => {
            if packet.routing_header.hops[packet.routing_header.hop_index] != self.id {
                let nack_packet =
                    self.nack_creator(&packet, NackType::UnexpectedRecipient(self.id));
                self.controller_send
                    .send(ControllerShortcut(nack_packet))
                    .unwrap();
                return;
            }

            packet.routing_header.hop_index += 1;
            let next_hop = packet.routing_header.hop_index;

            if next_hop == packet.routing_header.hops.len() {
                let nack_packet = self.nack_creator(&packet, NackType::DestinationIsDrone);
                self.controller_sender(ControllerShortcut(nack_packet));
                return;
            }

            if self
                .packet_send
                .contains_key(&packet.routing_header.hops[packet.routing_header.hop_index])
            {
                match &packet.pack_type {
                    PacketType::MsgFragment(frag) => {
                        let mut rng = rand::thread_rng();
                        let random_number = rng.gen_range(0.0..1.0);
                        if random_number > self.pdr {
                            self.packet_sender(packet.clone());
                            self.controller_sender(DroneEvent::PacketSent(packet));
                        } else {
                            let nack_packet = self.nack_creator(&packet, NackType::Dropped);
                            self.packet_sender(nack_packet.clone());
                            self.controller_sender(DroneEvent::PacketDropped(packet.clone()));
                            self.controller_sender(DroneEvent::PacketSent(nack_packet));
                        }
                    }
                    _ => {
                        self.packet_sender(packet.clone());
                        self.controller_sender(DroneEvent::PacketSent(packet));
                    }
                }
            } else {
                let nack_packet = self.nack_creator(
                    &packet,
                    NackType::ErrorInRouting(
                        packet.routing_header.hops[packet.routing_header.hop_index],
                    ),
                );
                self.packet_sender(nack_packet.clone());
                self.controller_sender(DroneEvent::PacketSent(nack_packet));
            }
        }
    }
}



fn nack_creator(&self, packet: &Packet, nack_type: NackType) -> Packet {
    let mut reverse_hops = packet.routing_header.hops.clone();
    reverse_hops.truncate(packet.routing_header.hop_index);
    reverse_hops.reverse();

    let nack = Nack {
        fragment_index: match &packet.pack_type {
            PacketType::Ack(ack) => ack.fragment_index,
            PacketType::Nack(nack) => nack.fragment_index,
            PacketType::MsgFragment(frag) => frag.fragment_index,
            _ => 0,
        },
        nack_type,
    };

    Packet {
        pack_type: PacketType::Nack(nack),
        routing_header: SourceRoutingHeader {
            hop_index: 1,
            hops: reverse_hops,
        },
        session_id: packet.session_id,
    }
}

fn floodrequest_creator(&self, packet: &Packet, floodrequest: FloodRequest) -> Packet {
    Packet {
        pack_type: PacketType::FloodRequest(floodrequest),
        routing_header: SourceRoutingHeader {
            hop_index: 0,
            hops: Vec::new(),
        },
        session_id: packet.session_id,
    }
}

fn floodresponse_creator(&self, packet: &Packet, flood_request: &FloodRequest) -> Packet {
    let mut reverse_hops = Vec::new();
    for (i, j) in flood_request.path_trace.clone() {
        reverse_hops.push(i);
    }
    reverse_hops.reverse();

    let floodresponse = FloodResponse {
        flood_id: flood_request.flood_id,
        path_trace: flood_request.path_trace.clone(),
    };

    Packet {
        pack_type: PacketType::FloodResponse(floodresponse),
        routing_header: SourceRoutingHeader {
            hop_index: 1,
            hops: reverse_hops,
        },
        session_id: packet.session_id,
    }
}

fn controller_sender(&self, packet: DroneEvent) {
    self.controller_send.send(packet).unwrap();
}

fn packet_sender(&self, packet: Packet) {
    let next_hop = packet.routing_header.hops[packet.routing_header.hop_index];
    self.packet_send
        .get(&next_hop)
        .unwrap()
        .send(packet.clone())
        .unwrap_or_else(|e| {
            println!("Error sending packet: {}", e);
            let nack_packet =
                self.nack_creator(&packet, NackType::ErrorInRouting(next_hop.clone()));
            self.controller_send
                .send(ControllerShortcut(nack_packet))
                .unwrap();
        });
}